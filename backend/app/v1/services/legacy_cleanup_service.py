"""Legacy artifact inspection and cleanup helpers."""

from __future__ import annotations

import sqlite3
import shutil
from dataclasses import dataclass
from pathlib import Path

from ..core.settings import settings


@dataclass
class LegacyCleanupReport:
    dry_run: bool
    removed_paths: list[str]
    blocked_paths: list[str]
    details: list[str]


class LegacyCleanupService:
    """Detect and prune legacy local artifacts with safety checks."""

    @staticmethod
    def _resolve_v1_db_path() -> Path | None:
        raw = settings.database_url.strip()
        marker = "sqlite+aiosqlite:///"
        if raw.startswith(marker):
            return Path(raw.replace(marker, "", 1))
        marker_sync = "sqlite:///"
        if raw.startswith(marker_sync):
            return Path(raw.replace(marker_sync, "", 1))
        return None

    @staticmethod
    def _load_v1_usernames(v1_db_path: Path) -> set[str]:
        if not v1_db_path.exists():
            return set()
        conn = sqlite3.connect(str(v1_db_path))
        try:
            cur = conn.cursor()
            cur.execute("SELECT username FROM v1_users")
            return {str(row[0]) for row in cur.fetchall() if row and row[0]}
        finally:
            conn.close()

    @staticmethod
    def _legacy_app_db_removable(legacy_db_path: Path, v1_usernames: set[str]) -> tuple[bool, str]:
        if not legacy_db_path.exists():
            return False, "Legacy app.db not found."

        conn = sqlite3.connect(str(legacy_db_path))
        try:
            cur = conn.cursor()
            cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='users'")
            if cur.fetchone() is None:
                return True, "Legacy app.db has no users table."

            cur.execute("SELECT username FROM users")
            legacy_usernames = {str(row[0]) for row in cur.fetchall() if row and row[0]}
        finally:
            conn.close()

        if not legacy_usernames:
            return True, "Legacy app.db has no user rows."

        missing = sorted(name for name in legacy_usernames if name not in v1_usernames)
        if missing:
            return False, f"Legacy app.db has users not present in v1 db: {', '.join(missing)}"
        return True, "All legacy app.db users are present in v1 db."

    @staticmethod
    def run_cleanup(*, dry_run: bool = True) -> LegacyCleanupReport:
        base_dir = Path.home() / ".inquira"
        removed_paths: list[str] = []
        blocked_paths: list[str] = []
        details: list[str] = []

        v1_db_path = LegacyCleanupService._resolve_v1_db_path()
        v1_usernames = (
            LegacyCleanupService._load_v1_usernames(v1_db_path)
            if v1_db_path is not None
            else set()
        )
        details.append(f"Loaded {len(v1_usernames)} usernames from v1 auth db.")

        # Remove orphan legacy username folders generated by old auth naming pattern.
        for child in sorted(base_dir.iterdir()) if base_dir.exists() else []:
            if not child.is_dir():
                continue
            if not child.name.startswith("user_"):
                continue
            if child.name in v1_usernames:
                blocked_paths.append(str(child))
                details.append(f"Preserved active user folder: {child}")
                continue
            if dry_run:
                removed_paths.append(str(child))
            else:
                shutil.rmtree(child)
                removed_paths.append(str(child))
            details.append(f"Orphan user folder {'scheduled' if dry_run else 'removed'}: {child}")

        # Remove top-level legacy workspaces dir only if empty.
        legacy_workspace_root = base_dir / "workspaces"
        if legacy_workspace_root.exists():
            entries = list(legacy_workspace_root.iterdir())
            if entries:
                blocked_paths.append(str(legacy_workspace_root))
                details.append(
                    f"Skipped removing {legacy_workspace_root}: directory is not empty ({len(entries)} entries)."
                )
            else:
                if dry_run:
                    removed_paths.append(str(legacy_workspace_root))
                else:
                    legacy_workspace_root.rmdir()
                    removed_paths.append(str(legacy_workspace_root))
                details.append(
                    f"Legacy workspaces dir {'scheduled' if dry_run else 'removed'}: {legacy_workspace_root}"
                )

        # Remove legacy app.db only when user records are represented in v1 auth db.
        legacy_app_db = base_dir / "app.db"
        removable, reason = LegacyCleanupService._legacy_app_db_removable(legacy_app_db, v1_usernames)
        details.append(reason)
        if removable:
            if dry_run:
                removed_paths.append(str(legacy_app_db))
            else:
                legacy_app_db.unlink(missing_ok=True)
                removed_paths.append(str(legacy_app_db))
        elif legacy_app_db.exists():
            blocked_paths.append(str(legacy_app_db))

        return LegacyCleanupReport(
            dry_run=dry_run,
            removed_paths=removed_paths,
            blocked_paths=blocked_paths,
            details=details,
        )
